#!/bin/sh

me=`basename "$0"`

pr_info ()
{
	format="$1"
	shift
	printf "$me: $format\n" "$@"
}

pr_err ()
{
	format="$1"
	shift
	printf "$me: error: $format\n" "$@" >&2
}

usage ()
{
	cat <<EOF
Fetch and apply patches from upstream automatically.

Usage:
  $me [OPTION]...

Options:
  -h, --help        Show this help and exit.

Bug reports can be sent to <rakinar2@osndevs.org>.
EOF
}

if ! command -v curl > /dev/null 2>&1; then
	pr_err "curl is required to use this script!"
	exit 1
fi

if ! command -v jq > /dev/null 2>&1; then
	pr_err "jq is required to use this script!"
	exit 1
fi

while test $# -gt 0; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;

		-*)
			pr_err "Invalid option '%s'" "$1"
			exit 1
			;;

		*)
			pr_err "Invalid argument '%s'" "$1"
			exit 1
			;;
	esac
done

owner="onesoft-sudo"
repo="sudoc"

topdir=`git rev-parse --show-toplevel`
branch=`git branch --show-current`

if test -f "${topdir}/.lastpatch"; then
	base=`cat "${topdir}/.lastpatch"`
fi

if test -z "$base"; then
	pr_info "No .lastpatch file was found in the repository root. Assuming this is the first run."
	pr_info "A .lastpatch file will be created. No patches will be applied on this run."
	pr_info "Fetching last commit hash..."
	base=`curl -fSsL -X GET -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/$owner/$repo/commits/main" | jq -r '.sha'`
	printf "%s\n" "$base" > "${topdir}/.lastpatch"
	exit 0
fi

pr_info "Last patch commit: $base"
pr_info "Fetching new patches from upstream ${owner}/${repo}..."

patch_tmp=`mktemp`

curl -fSsL -X GET \
	-H "X-GitHub-Api-Version: 2022-11-28" \
	-H "Accept: application/vnd.github.v3.patch" \
	"https://api.github.com/repos/$owner/$repo/compare/$base...main" > "$patch_tmp"

if test -z "$(cat "$patch_tmp")"; then
	pr_info "No patch is available right now."
	exit 0
fi

pr_info "Patches fetched. Applying now..."

filter_opts=''

if test -f "${topdir}/.patchignore"; then
	while read -r ign; do
		filter_opts="${filter_opts} --exclude=\"${ign}\""
	done < "${topdir}/.patchignore"
fi

trap 'rm -f $patch_tmp' EXIT INT TERM

if ! eval "git am -3 $filter_opts \"$patch_tmp\""; then
	pr_err "Patches did not apply (possible conflict). Bailing out, you're on your own. Fix the conflicts manually."

	patchfile="update.patch"
	mv "$patch_tmp" "$patchfile"
	pr_info "The patch is saved at '%s'" "$patchfile"

	git am --abort
	exit 1
fi

printf "%s\n" "$(git rev-parse "$branch")" > "${topdir}/.lastpatch"
pr_info "Successfully applied the patches."
